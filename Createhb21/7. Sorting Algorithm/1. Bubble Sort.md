사실 버블 정렬은 전혀 효율적이지 않다. 그렇게 자주 쓰이지도 않는다. 그래도 어떻게 하는지 알면 아주 재밌긴 할 것이다. 그리고 실제로 우리가 최적화를 할 수도 있다. 

배열을 가지고 작은 것부터 큰 것 순서로 정렬을 한다고 할 때, 더 큰 값이 한 번에 하나씩 꼭대기로 버블을 타고 올라가도록 하기 때문에 버블 정렬이라고 부른다. 

## 버블 정렬이 작동하는 방식

- 버블 정렬은 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를, 세 번째와 네 번째를, … 이런 식으로 (마지막-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다.
- 1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 자료는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 자료까지는 정렬에서 제외된다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.

버블 정렬의 핵심은 인접한 요소들끼리의 값을 비교하고 그 후 서로의 자리를 바꿔준다는 것이다. 자바스크립트에는 자리를 바꿔주는 방법이 두 가지 정도 존재한다.

```tsx
// ES 5
function swap(arr, idx, idx2) {
	let temp = arr[idx1];
	arr[idx1] = arr[idx2];
	arr[idx2] = temp;
}

// ES 2015
const swap = (arr, idx1, idx2) => {
	[arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
}
```

따라서 버즐 정렬의 실제 논리 구조는 루프를 가지고 비교한 다음에 swap을 호출하는 방식으로 이루어져 있다. 그렇지만 실제 코딩할 때는 굳이 다른 함수를 정의할 필요가 없으니 다음 방법을 더 추천한다.

```tsx
function bubbleSort(arr){
	for(let i = 0; i < arr.length; i++) {
		for(let j = 0; j < arr.length; j++) {
			if(arr[j] > arr[j+1]) {
				//SWAP//
				let temp = arr[j];
				arr[j] = arr[j+1];
				arr[j+1] = temp;
			}	
		}
	} 
  return arr;
}

bubbleSort([37, 45, 29, 8]);
```

위의 코드 방식 또한 제대로 작동하는 버블 정렬이지만, 최적화를 하지는 않았다. 따라서 필요 이상의 모든 루프를 다 돌게된다. 우리는 최적화를 통해 쓸데없는 비교의 횟수를 줄일 수 있다. 다음은 최적화를 한 버블 정렬 코드를 작성한다. 

```tsx
// 위 함수에서 루프가 작동하는 방식을 수정하여 최적화를 해보자.

// 1. i 라는 변수로 배열의 맨 뒤에서 앞으로 루프를 돈다. 기본적으로 정렬하는 공간을 줄여나가야 하기 때문에 맨 뒤에서 출발함.
// 2. j 라는 변수를 가지고 이번에는 앞에서부터 (i - 1)까지 루프를 걸어준다. 
// 3. arr[j]와 arr[j+1]을 비교해주고 arr[j+1]이 더 크다면 두 요소의 자리를 바꿔준다.
// 4. 루프가 끝나면 마지막에 정렬된 배열을 리턴한다.

function bubbleSort(arr){
	for(let i = arr.length; i > 0 ; i--) {
		for(let j = 0; j < i - 1 j++) {
			if(arr[j] > arr[j+1]) {
				//SWAP//
				let temp = arr[j];
				arr[j] = arr[j+1];
				arr[j+1] = temp;
			}	
		}
		// console.log("One Pass Complete")
	}
	return arr;
}

bubbleSort([37, 45, 29, 8]);
bubbleSort([37, 45, 29, 8, 12, 88, -3]);
```

```tsx
// ES 2015 
function bubbleSort(arr) {
	const swap = (arr, idx1, idx2) => {
		[arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]]
	};

	for (let i = arr.length; i > 0; i--) {
		for (let j = 0; j < i - 1; j++) {
			if (arr[j] > arr[j+1]) {
				swap(arr, j, j+1);
			}
		}
	}
	return arr;
}

bubbleSort([37, 45, 29, 8, 12, 88, -3]);
```

하지만 아직 보완할 점이 남아있다. 

![스크린샷 2022-01-12 오후 5.06.36.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d5f2ff6a-1e10-4982-b224-5605be03650a/스크린샷_2022-01-12_오후_5.06.36.png)

위와 같이 정렬이 거의 되어있는 배열에 대해서는 위의 코드는 다시 필요이상으로 모든 루프를 돌면서 정렬을 하려고 할 것인데, 이는 매우 불필요하다. 따라서 약간의 보완이 필요한데 아이디어는 다음과 같다. ‘지난 번 순환에서 자리 바꾸기를 했었나?’ 만약 자리 바꾸기를 하지 않았다면 더 이상 배열을 순활할 필요가 없어진다. 즉, 이미 정렬이 끝났다는 것이다. 

매우 거대한 배열을 가지고 작업을 한다고 생각한다면, 이러한 자그마할 수 있는 차이가 결과적으로는 큰 차이를 만들어 낸다. 

### Optimized with noSwapss

```tsx
// 새로운 변수를 하나 만들어주는데, 이름은 noSwaps로 하자. 만약 이 변수의 값이 true라면 자리 바꾸기가 없었던 것이고 루프를 깨고 나오면 된다. 
// noSwaps의 값은 루프를 돌 때마다 true값으로 할당해주면서, 만약 인접한 두 요소간에 자리 바꾸기가 있었을 경우에만 noSwaps의 값을 false로 할당한다.

function bubbleSort(arr){
	let noSwaps;
	for(let i = arr.length; i > 0 ; i--) {
		noSwaps = true;
		for(let j = 0; j < i - 1 j++) {
			if(arr[j] > arr[j+1]) {
				let temp = arr[j];
				arr[j] = arr[j+1];
				arr[j+1] = temp;
				noSwaps = false;
			}	
		}
		**if(noSwaps) break;**
	}
	return arr;
}

// 어느정도 정렬이 되어 있는 배열
bubbleSort([8, 1, 2, 3, 4, 5, 6, 7]);
```

## About Big O

일반적으로는 중첩 루프를 가지고 있어서 배열에 있는 모든 요소들을 비교하니까 n제곱의 값을 가진다. 그렇지만 데이터가 거의 정렬이 되어 있는 경우에는 위와 같은 noSwaps를 활용한 코드를 사용할 수 있는데 그러면 거의 1차함수 관계인 n의 값을 가질 수 있다. 즉, 가장 좋은 경우에는 빅오(n)의 값을 가진다. 

하지만 거의 정렬이 되어있는 데이터를 가진 배열을 받는다고 해서 버블 정렬을 우선적으로 고려할 것은 아니고, 앞으로 계속 다뤄볼 다른 알고리즘들과 함께 고려해볼 수는 있겠다.